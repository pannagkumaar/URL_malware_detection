import re
import difflib
import requests
from urllib.parse import urlparse
from rich.console import Console
from datetime import datetime
def check_typosquatting(file_path, input_url, threshold=0.75):
    if input_url.startswith("http://"):
        input_url = input_url[7:]
    elif input_url.startswith("https://"):
        input_url = input_url[8:]
       
    def sequence_matcher_similarity(text1, text2):
        seq_matcher = difflib.SequenceMatcher(None, text1, text2)
        return seq_matcher.ratio()

    with open(file_path, "r") as file:
        urls = [line.strip() for line in file.readlines()]
        

    input_url = input_url.lower().replace("www.", "")

    potential_typosquatting = []

    for url in urls:
        url = url.lower().replace("www.", "")
        similarity = sequence_matcher_similarity(input_url, url)
        if similarity >= threshold:
            potential_typosquatting.append({"url": url, "similarity": similarity})

    return potential_typosquatting

def has_shortening_service(url):
    pattern = re.compile(r'https?://(?:www\.)?(?:\w+\.)*(\w+)\.\w+', re.IGNORECASE)
    match = pattern.search(url)
    
    if match:
        domain = match.group(1).lower()
        common_shortening_services = {'bit', 'goo', 'tinyurl', 'ow', 't', 'is',
                                      'cli', 'yfrog', 'migre', 'ff', 'url4', 'twit',
                                      'su', 'snipurl', 'short', 'BudURL', 'ping', 
                                      'post', 'Just', 'bkite', 'snipr', 'fic', 
                                      'loopt', 'doiop', 'short', 'kl', 'wp', 
                                      'rubyurl', 'om', 'to', 'bit', 't', 'lnkd', 
                                      'db', 'qr', 'adf', 'goo', 'bitly', 'cur', 
                                      'tinyurl', 'ow', 'bit', 'ity', 'q', 'is', 
                                      'po', 'bc', 'twitthis', 'u', 'j', 'buzurl', 
                                      'cutt', 'u', 'yourls', 'x', 'prettylinkpro', 
                                      'scrnch', 'filoops', 'vzturl', 'qr', '1url', 
                                      'tweez', 'v', 'tr', 'link', 'zip'}
        
        if domain in common_shortening_services:
            return 1
    return 0




def check_unusual_structure(path):
    # Check for unusual URL structure
    # Implement your own logic based on path analysis

    # 1. Long Sequences of Repeating Characters
    consecutive_repeating_chars = re.search(r'(.)\1{5,}', path)
    if consecutive_repeating_chars:
        return True

    # 2. Uncommon Symbols
    uncommon_symbols = set(path) - set('abcdefghijklmnopqrstuvwxyz0123456789-._/')
    if uncommon_symbols:
        return True

    # 3. Excessive Use of Hyphens or Underscores
    excessive_hyphens_underscores = re.search(r'[-_]{4,}', path)
    if excessive_hyphens_underscores:
        return True

    # 4. Unusual Path Length
    if len(path) > 50:
        return True

    # 5. Presence of Hexadecimal Encoding
    if re.search(r'%[0-9A-Fa-f]{2}', path):
        return True

    # 6. Uncommon File Extensions
    uncommon_extensions = re.search(r'\.\w{4,}', path)
    if uncommon_extensions:
        return True

    # If none of the checks found anything unusual
    return False





def check_https_anomalies(url):
    console=Console()
    try:
        # Ensure the URL starts with 'https://'
        if not url.startswith('https://'):
            console.print("[gold][!][/gold] URL does not use HTTPS.")
            return True

        # Retrieve SSL certificate
        response = requests.head(url, allow_redirects=True, timeout=5)
        if response.status_code == 200 and response.url.startswith('https://'):
            parsed_url = urlparse(url)
            domain = parsed_url.netloc

            # Check if the SSL certificate is valid
            cert = response.connection.sock.getpeercert()
            not_after = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
            if not_after < datetime.now():
                print("SSL certificate has expired.")
                return True

            # Check if the common name matches the domain
            common_name = cert['subject'][0][0][1]
            if not common_name.lower() == domain.lower():
                print(f"Common name in SSL certificate does not match the domain: {common_name}")
                return True

            # Check if the certificate is issued by a trusted authority
            issuer = cert['issuer'][0][0][1]
            trusted_authorities = ['Let\'s Encrypt', 'DigiCert', 'Comodo', 'Symantec', 'GeoTrust']
            if not any(authority.lower() in issuer.lower() for authority in trusted_authorities):
                print(f"Certificate issuer is not from a trusted authority: {issuer}")
                return True

            # Add more checks as needed based on your specific requirements

    except requests.exceptions.RequestException as e:
        print(f"Error checking HTTPS anomalies: {e}")

    return False

def check_dynamic_parameters(query, threshold=3):
    # Check for dynamic parameters
    # Implement more sophisticated logic based on query analysis

    # Split the query string into individual parameters
    parameters = [param.split('=') if '=' in param else (param, '') for param in query.split('&')]

    # Check the total number of parameters
    if len(parameters) > threshold:
        return True

    # Check for specific patterns in parameter names or values
    for param in parameters:
        # Ensure that the parameter has both a name and a value
        if len(param) == 2:
            # Check for numeric values (considering decimals)
            if re.match(r'^[+-]?\d*\.?\d+$', param[1]):
                return True

            # Check for suspicious characters in parameter names or values
            if re.search(r'[^\w.-]', param[0]) or re.search(r'[^\w.-]', param[1]):
                return True

            # Improve SQL injection detection
            if re.search(r'\b(union|select|insert|update|delete|alter|drop|truncate|exec)\b', param[1], re.IGNORECASE):
                return True

            # Enhance XSS detection
            if re.search(r'<\s*/?\s*script\s*>', param[1], re.IGNORECASE):
                return True

            # Check for parameter names commonly used in attacks
            if param[0].lower() in ['script', 'exec', 'cmd', 'system', 'eval']:
                return True

            # Check for excessively long parameter values
            if len(param[1]) > 50:
                return True

        # Add more checks based on your specific requirements

    # If none of the checks found anything suspicious
    return False

def is_suspicious_tld(domain):
    # Make the comparison case-insensitive
    domain_lower = domain.lower()

    # List of suspicious TLDs
    suspicious_tlds = [
        '.tk', '.ml', '.ga', '.cf', '.gq',
        '.pw', '.to', '.cc', '.ws', '.su',
        '.buzz', '.download', '.guru', '.loan', '.racing',
        '.review', '.top', '.vip', '.win', '.work',
        '.country', '.stream', '.download', '.xin', '.gdn',
        '.jetxt', '.bid', '.vip', '.ren', '.kim',
        '.loan', '.mom', '.party', '.review', '.trade',
        '.date', '.wang', '.accountants'
        # Add more TLDs as needed
    ]

    # Check if the domain or any of its subdomains end with a suspicious TLD
    return any(domain_lower.endswith(tld) or domain_lower.endswith(f"{tld}.") for tld in suspicious_tlds)
